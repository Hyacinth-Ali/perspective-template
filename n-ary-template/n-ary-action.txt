
// create type
public createElement(p1, p2, ...) {
  element = create(p1, p2, ...);
  createElements(element, p1, p2, ...);

  // secondary effects
  for (actionEffect : secondaryEffects) {
    // getSecondaryElement is a helper method which returns the affected element
    // this can work for create and update actions.
    // Assumption: if another element is created (e.g., lifeline), which has LEM and is a
    // sub-element of the newly created element (e.g., sequence diagram), then it is not covered.
    // TODO: delete type
    secondaryElement = getSecondaryElement(actionEffect);
    if (actionEffect.languageAction.actionType == CREATE) {
      createElements(secondaryElement, p1, p2, ...);
    } else if(actionEffect.languageAction.actionType == UPDATE) {
      updateElement(secondaryElement, p2, p3, ...)
    }
  }
}
private createElements(element, p1, p2, ...) {
  for (MappingType type : getMappingTypes(element)) {
      mappings = getMappings(type, element);
      metaclasses = getOtherMetaClasses(type, element);
      otherElemets = null;
      for (EObject metaclass: metaclasses) {
        // TODO: n-ary create types
        // the create type may use binary relationships for the concerned elements
        switch(getCreateType(type)) {
          case CAN_CREATE:
            if (mappings.size() == 0 ) {
              boolean isOther = isCreateOther();
              if (isOther) {
                other = CREATE(metaclass, p1, p2, ...);
                otherElemets.add(other);
              }
            }
            break;
          case CREATE_OR_USE_NON_MAPPED:
            if (mappings.size() == 0) {
              other = findCorrespondingElement();
              if (other == null ||
                getMappings(other).size() > 0) {
                  other = CREATE(metaclass, p1, p2, ...);
                }
                otherElemets.add(other);
              }
              break;
            case . . .
          }
      }
      createMapping(type, element, otherElemets);
      for (other: otherElemets) {
        createElements(other, p1, p2, ...);
      }
      }
    }

    // delete type
    public deleteElement(element, p2, p3, ...) {
      deleteElements(element, p2, p3, ...);
    }
    private deleteElements(element, p2, p3, ...) {
      mappings = getMappings(element);
      for (Mapping mapping : mappings) {
        others = getOtherElements(mapping, element);
        otherElemets = null;
        for (EObject other: others) {
          // TODO: n-ary delete types
          // the delete type may use binary relationships for the concerned elements
          deleteType = getDeleteType(mapping);
          mappingType = mapping.getMappingType();
          switch(deleteType) {
            case JUST_DELETE:
              // do nothing, action already covered
              break;
            case DELETE_OTHERS:
              otherElemets.add(other);
              break;
            case DELETE_SINGLE_MAPPED:
              otherMappings =
              getMappings(mappingType, other);
              if (otherMappings.size() == 0) {
                otherElemets.add(other);
              }
              break;
            }
        }
        mapping.delete();
        DELETE(element, p2, p3, ...);
        for (EObject other: others) {
          deleteElements(other, p2, p3, ...);
        }
      }
    }

    // Update type
    updatedElements = new ArrayList<EObject>();
    public updateElement(element, p2, p3, ...) {
      updatedElements.clear();
      updateElements(element, p2, p3, ...);
      updatedElements.clear();
    }
    private updateElements(element, p2, p3, ...) {
      UPDATE(element, p2, p3, ...);
      updatedElements.add(element);
      for (Mapping mapping : getMappings(element)) {
        other = getOther(mapping, element);
        // perspective recursive call
        if (!updatedElements.contains(other)) {
          updateElements(other, p2, p3, ...);
        }
      }
    }
